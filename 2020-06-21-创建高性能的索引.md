---
layout: post
title:  "创建高性能的索引"
date:   2020-06-21 20:00:00 +0800
categories: 高性能mysql
tags: mysql
description: 笔记
---

# 索引基础

## 索引的类型

* B-Tree索引

    * B+Tree非叶子节点不需要存储节指向数据的指针，所以一个页中能存储更多的键值，I/O次数更少
    * B+Tree叶子节点是连接起来的有序链表，全表扫描速度更快。而B-Tree全表扫描可能会导致更多的I/O
    * B-Tree节点离根节点更近，查找次数更少

  B-Tree索引适用于：
    
    * 全值匹配
        
      全值匹配是指和索引中的所有列进行匹配

    * 匹配最左前缀
      
      只使用索引的第一列
    
    * 匹配列前缀
      
      只匹配某一列的值的开头部分

    * 匹配范围值

      只用到了索引的第一列  

    * 精确匹配某一列并范围匹配另一列
      
      索引第一列能使用到索引
    
    * 之访问索引的查询
      
      查询只需访问索引

  B-Tree索引的限制：
    
    * 不能跳过索引中的列
    * 如果查询中某个列的范围查询，则其右边所有列都无法使用使用索引优化查找。
  
* 哈希索引
  
  对于每一行数据，存储引擎都会对所有的索引列计算出一个哈希值。只有Memory引擎限制支持哈希索引。

  哈希索引自身只需存储对应的哈希值，所以索引的结构十分紧凑，这也让哈希索引查找的速度非常快。

  哈希索引的限制：

    * 哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行
    * 哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序
    * 哈希索引也不支持部分索引列匹配查找，因为哈希索引使用是使用索引列内的全部内容来计算哈希值的
    * 哈希索引只支持等值比较查询，也不支持任何范围查询
    * 访问哈希索引的数据非常快，除非有很多哈希冲突
    * 如果哈希冲突很多的化，一些索引维护操作的代价也会很高

当InnoDB注意到某些索引值被使用的非常频繁是，它会在内存中基于B-Tree索引之上再创建一个哈希索引，这样就让B-Tree索引也据哟与哈希索引的一些优点。

 * 空间索引

    MyISAM表支持空间索引，可以用作地理数据存储

 * 全文索引

    查找的是文本中的关键字，而不是直接比较索引中的值。

# 索引的优点

  * 减少服务器需要扫描的次数
  * 可以帮助服务器避免排序和临时表
  * 可以将随机I/O变为顺序I/O

# 高性能的索引策略

## 独立的列

  索引列不能是表达爱是的一部分，也不能是函数的参数
  
## 前缀索引和索引的选择性

可以选择列开始的部分字符作为索引，可以节约索引空间，从而提高效率。但这样重复的索引值也会更多。而且MySQL无法使用前缀索引做ORDER BY和GROUP BY，也无法使用前缀索引做覆盖扫描

## 多列索引

  * 当出现服务器对多个索引做相交操作时，通常意味着需要一个包含所有相关列的多列索引，而不是多个独立的单列索引
  * 当服务器需要对多个索引做联合操作时，通常需要耗费大量的CPU和内存资源在算法缓存、排序和合并操作上。特别时当其中有些索引的选择性不高，需要合并扫描返回的大量数据的时候
  * 优化器不会把这些计算到“查询成本”中，优化器只关心随机页面读取

  如果在EXPLAIN中看到有索引合并，应该检查查询和表结构，看是不是已经是最优的。也可以通过optimizer_switch来关闭索引合并功能。也可以使用IGNORE INDEX提示让优化器忽略掉某些索引。

## 选择合适的索引序列

  将选择性高的列放到索引最前列

## 聚簇索引

  表示数据行和相邻的键值紧凑的存储在一起。因为无法同时把数据行存放在两个不同的地方，所以一个表之只能有一个聚簇索引。InnoDB通过主键聚集数据。如果没有定义主键，InnoDB会选择一个唯一的非空索引代替，如果没有这样的索引，InnoDB会隐式定义一个主键来作为聚簇索引。

  聚簇索引优点：

  * 可以把相关数据保存在一起
  * 数据访问更快
  * 使用覆盖索引扫描的查询可以直接的使用页面节点中的主键值

  聚簇索引缺点：
      
  * 聚簇数据最大限度地提高了I/O密集型应用的性能，但如果数据全部都放在内存中，则访问的顺序就没有那么重要了
  * 插入速度严重依赖于插入顺序。按照主键的顺序插入是加载数据到InnoDB表中速度最快的方式。但如果不是按照主键顺序加载数据，那么在加载完成后最好使用OPTIMIZE TABLE命令重新组织一下表。
  * 更新聚簇索引列的代价很高。因为会强制InnoDB将每个被更新的行移动到新的位置
  * 基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临“页分裂”的问题。
  * 聚簇索引可能会导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候
  * 二级索引可能比想象的要更大，因为在二级索引的叶子节点包含了引用行的主键列
  * 二级索引访问需要两次索引查找，而不是一次。二级索引存储的是主键值，需要根据主键值去聚簇索引中查找对应的行。

  InnoDb和MyISAM的数据分布对比
    
  * MyISAM的数据分布：按照数据插入的顺序存储在磁盘上。主键索引和其他索引在结构上没有什么区别
  * InnoDB的数据分布：聚簇索引就是就是表。二级索引叶子节点中存储的不是行指针，而是主键值
  * 在innoDB表中按主键顺序插入行

  在InnoDB中按主键顺序插入可能会造成明显的争用。并发插入可能导致间隙锁竞争，另一个是AUTO_INCREMENT锁机制，可以更改innodb_autoinc_lock_mode配置。

## 覆盖索引
  
  索引包含所有需要查询的字段的值，就称之为覆盖索引。

  优点：

  * 索引条目通常远小于数据行大小，所以如果只需要读取索引，那么MySQL就会极大的减少数据访问量
  * 因为索引是按照列值顺序存储，所以对于I/O密集型的范围查询就会比随机从磁盘读取每一行数据的I/O要少得多。
  * 一些存储引擎如MyISAM在内存中只会缓存索引，数据则依赖于操作系统来缓存，因此要访问数据需要一次操作系统调用
  * 由于InnoDB的聚簇索引，覆盖索引对InnoDB表特别有用。InnoDB的二级索引在叶子节点中保存了行的主键值，所以如果二级主键能够覆盖查询，则可以避免对主键索引的二次查询
  
## 使用索引扫描来做排序

  只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向都一样是，MySQL才能够使用索引来对结果做排序。如果查询需要关联多张表，则只有当ORDER BY子句引用的字段全部为第一个表时，才能使用索引做排序。ORDER BY字句和查找型查询的限制是一样的：需要满足索引的最左前缀的要求；否则，MySQL都需要执行排序操作，而无法利用索引排序。

  有一种情况下ORDER BY子句可以不满足索引的最左前缀的要求，就是前导列为常量的时候。

## 压缩（前缀压缩）索引
  
  MyISAM使用前缀压缩来减少索引的大小，从而让更多的索引可以放入内存中，这在某些情况下能极大的提高性能。

## 冗余和重复索引
  
  * 如果创建了索引(A,B)，再创建索引(A)就是冗余索引

* 未使用的索引

* 索引和锁

# 索引案例学习

  * 支持多种过滤条件

    可以通过IN包含所有值来使得查询使用索。将需要范围查询的列放到索引的后面
  
  * 避免多个范围条件

    会导致无法使用索引

  * 优化排序

    对于选择性非常低的列，先使用覆盖索引取得所需主键，然后通过主键进行查询。

# 维护索引和表

  * 找到并修复损坏的表

    CHECK TABLE命令可以检查是否发生了表损坏，REPAIR TABLE命令来修复损坏的表。也可以通过一个不做任何操作的ALTER操作来重建表。

  * 更新索引统计信息

    通过运行ANALYZE TABLE来重新生成统计信息。

  * 减少索引和数据碎片

    InnoDB可以通过删除在重新创建索引的方式来消除索引的碎片化。

    