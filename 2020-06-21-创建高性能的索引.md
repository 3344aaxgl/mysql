---
layout: post
title:  "创建高性能的索引"
date:   2020-06-21 20:00:00 +0800
categories: 高性能mysql
tags: mysql
description: 笔记
---

# 索引基础

## 索引的类型

* B-Tree索引

    * B+Tree非叶子节点不需要存储节指向数据的指针，所以一个页中能存储更多的键值，I/O次数更少
    * B+Tree叶子节点是连接起来的有序链表，全表扫描速度更快。而B-Tree全表扫描可能会导致更多的I/O
    * B-Tree节点离根节点更近，查找次数更少

  B-Tree索引适用于：
    
    * 全值匹配
        
      全值匹配是指和索引中的所有列进行匹配

    * 匹配最左前缀
      
      只使用索引的第一列
    
    * 匹配列前缀
      
      只匹配某一列的值的开头部分

    * 匹配范围值

      只用到了索引的第一列  

    * 精确匹配某一列并范围匹配另一列
      
      索引第一列能使用到索引
    
    * 之访问索引的查询
      
      查询只需访问索引

  B-Tree索引的限制：
    
    * 不能跳过索引中的列
    * 如果查询中某个列的范围查询，则其右边所有列都无法使用使用索引优化查找。
  
* 哈希索引
  
  对于每一行数据，存储引擎都会对所有的索引列计算出一个哈希值。只有Memory引擎限制支持哈希索引。

  哈希索引自身只需存储对应的哈希值，所以索引的结构十分紧凑，这也让哈希索引查找的速度非常快。

  哈希索引的限制：

    * 哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行
    * 哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序
    * 哈希索引也不支持部分索引列匹配查找，因为哈希索引使用是使用索引列内的全部内容来计算哈希值的
    * 哈希索引只支持等值比较查询，也不支持任何范围查询
    * 访问哈希索引的数据非常快，除非有很多哈希冲突
    * 如果哈希冲突很多的化，一些索引维护操作的代价也会很高

当InnoDB注意到某些索引值被使用的非常频繁是，它会在内存中基于B-Tree索引之上再创建一个哈希索引，这样就让B-Tree索引也据哟与哈希索引的一些优点。

 * 空间索引

    MyISAM表支持空间索引，可以用作地理数据存储

 * 全文索引

    查找的是文本中的关键字，而不是直接比较索引中的值。

## 索引的优点

  * 减少服务器需要扫描的次数
  * 可以帮助服务器避免排序和临时表
  * 可以将随机I/O变为顺序I/O

## 高性能的索引策略

  * 独立的列

    索引列不能是表达爱是的一部分，也不能是函数的参数
  
  * 前缀索引和索引的选择性

    可以选择列开始的部分字符作为索引，可以节约索引空间，从而提高效率。但这样重复的索引值也会更多。而且MySQL无法使用前缀索引做ORDER BY和GROUP BY，也无法使用前缀索引做覆盖扫描

  * 多列索引

    * 当出现服务器对多个索引做相交操作时，通常意味着需要一个包含所有相关列的多列索引，而不是多个独立的单列索引
    * 当服务器需要对多个索引做联合操作时，通常需要耗费大量的CPU和内存资源在算法缓存、排序和合并操作上。特别时当其中有些索引的选择性不高，需要合并扫描返回的大量数据的时候
    * 优化器不会把这些计算到“查询成本”中，优化器只关心随机页面读取

    如果在EXPLAIN中看到有索引合并，应该检查查询和表结构，看是不是已经是最优的。也可以通过optimizer_switch来关闭索引合并功能。也可以使用IGNORE INDEX提示让优化器忽略掉某些索引。

  * 选择合适的索引序列

    将选择性高的列放到索引最前列

  * 聚簇索引

    
