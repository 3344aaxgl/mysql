---
layout: post
title:  "查询性能优化"
date:   2020-06-27 15:00:00 +0800
categories: 高性能mysql
tags: mysql
description: 笔记
---

# 为什么查询会慢

# 慢查询基础： 优化数据访问

* 确认应用程序是否在检索大量超过需要的数据，这通常意味着访问太多的行，但有时候也可能是访问了太多的列。
* 确认MySQL服务器层是否在分析大量超过需要的数据行

## 是否向数据库请求了不需要的数据

  * 查询不需要的记录
  * 多表关联式返回全部列
  * 总是取出全部列
  * 重复查询相同的数据

## MySQL是否在扫描额外的记录

  * 响应时间

    包括服务时间和排队时间。服务时间是指数据库处理这个查询真正花了多长时间，排队时间是指服务器因为等待某些资源而没有真正执行查询的时间。
  * 扫描的行数和返回的行数。
  * 扫描的行数和访问的类型

    在EXPLAIN语句中的type列反映了访问类型。

    一般MySQL能够使用如下三种方式应用WHERE条件，从好到坏依次为：

    * 在索引中使用where条件来过滤不匹配的记录
    * 使用索引覆盖扫描（在Extra列中出现了Using index）来返回记录，直接从索引中过滤不需要的记录并返回名字的结果
    * 从数据表中返回数据，然后过滤不满足条件的记录（在Extra列中出现Using Where）

    如果发现查询需要扫描大量的数据但只返回少数的行，那么可以尝试下面的技巧去优化：

    * 使用索引覆盖扫描
    * 改变库表结构
    * 重写查询

# 重构查询的方式

  * 一个复杂查询还是多个简单查询

    考虑是否需要将一个复杂的查询分成多个简单的查询
  * 切分查询

    将大查询切分成小查询，每个查询功能完全一样，只完成一小部分，每次只返回一小部分查询结果。
  * 分解关联查询

    对每一个表进行一次单表查询，然后将结果在应用程序中进行关联。

    用分解关联查询的方式重构查询有如下的优势：

    * 让缓存的效率更高
    * 将查询分解后，执行单个查询可以减少锁的竞争
    * 在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展
    * 查询本身效率也可能会有所提升
    * 可以减少冗余记录的查询
    * 这样做相当于在应用中实现了哈希关联，而不是使用MySQL的嵌套循环关联

# 查询执行的基础

## MySQL客户端/服务器通信协议

  MySQL客户端和服务器之间的通信协议是“半双工”的。多数连接MySQL的库函数都可以获得全部结果集并缓存到内存里，还可以逐行获取需要的数据。如果需要返回一个很大的结果集，可以不使用缓存来记录结果而是直接处理。

## 查询状态

  * Sleep 线程正在等待客户端发送新的请求
  * Query 线程正在执行查询或者正在将结果发送给客户端
  * Locked 在MySQL服务器层，该线程正在等待表锁
  * Analyzing and statistics 线程正在收集存储引擎统计信息，并生成查询的执行计划
  * Coping to tmp table [on disk] 线程正在执行查询，并且将其结果都复制到一个临时表中。
  * Sorting result 线程正在对结果集进行排序
  * Sending data 县城可能在多个状态之间传送数据，或者在生成结果集，或者在向客户端返回数据

## 查询缓存

  在解析一个查询语句之前，如果查询缓存是打开的，那么MySQL会优先检查这个查询是否名字查询缓存中的数据。这个检查是通过一个对大小写铭感的哈希查找实现的。

## 查询优化处理

  * 语法解析器和预处理

    MySQL通过关键字将SQL语句进行解析，并生成一颗对应的“解析树”。MySQL解析器将使用MySQL语法规则验证和解析查询。

  * 查询优化器

    一条查询可以有很多种执行方式，最后都返回相同的结果。优化器的作用就是找到这其中最好的执行计划。

    有很多种原因会导致MySQL优化器选择错误的执行计划：

    * 统计信息不准确
    * 执行计划中的成本估算不等同于实际执行的成本
    * MySQL的最优可能和你想的最优不一样
    * MySQL从不考虑其他并发执行的查询
    * MySQL也并不是任何时候都是基于成本的优化，有时也会基于一些固定规则
    * MySQL不会考虑不受控制的操作成本，如执行存储过程或者用户自定义函数

    MySQL能够处理的优化类型：

      * 重新定义关联表的顺序 
      * 将外，i按揭转化成内连接
      * 使用等价变换规则
      * 优化COUNT()、MIN()、MAX()
      * 预估并转化为常数表达式

        当MySQL检测到一个表达式可以转化为常数的时候，就会一直把该表达式作为常数进行优化处理
      * 覆盖索引扫描
      * 子优化查询
      * 提前终止查询

        发现已经满足查询需求的时候，MySQL总是能够立即终止查询。

      * 等值传播

        如果两个列的值通过等式关联，那么MySQL能够把其中一个列的WHERE条件传递到另一个列上
      
      * 列表in()的比较

        MySQL将IN()列表中的数据先进行排序，然后通过二分查找的方式来确定列表中的值是否满足条件

  * 数据和索引的统计信息

    每个表或者索引有多少个页面、每个表的每个索引的基数是多少、数据行和索引长度、索引的分布信息

  * MySQL如何执行关联查询

    MySQL对任何关联都执行嵌套循环关联操作，即MySQL先在一个表中循环取出单条数据，然后再嵌套循环到下一个表中寻找匹配行，依次下去，直到找到所有表中匹配的行为止。然后根据各个表匹配的行，返回查询中需要的各个列。

  * 执行计划
    
    MySQL生成查询的以可指令树，然后通过存储引擎执行完成这颗指令树并返回结果。

  * 关联查询优化器

    关联查询优化器通过评估不同顺序的成本来选择一个代价最小的关联顺序。有时优化器给出的并不是最优的关联顺序。这时可以使用STRAIGHT_JOIN关键字重写查询，让优化器按照你认为的最有关联顺序执行。

  * 排序优化

    如果不能使用索引生成排序结果的时候，MySQL需要自己进行排序，如果数据量小则在内存中进行，如果数据量大则需要使用磁盘。

    在关联查询时如果需要排序，如果ORDER BY字句中的所有列都来自关联的第一个表，那么MySQL在关联处理第一个表的时候就会进行文件排序，Extra字段就会有"Using filesort"，除此之外的所有情况，都会先将关联的结果存放到一个临时表中，然后在所有的关联都借宿后，在进行文件排序，Extra字段中可以看到“Using temporary； Using filesort”

## 查询执行引擎

## 返回结果给客户端

# MySQL查询优化器的局限性

## 关联子查询

exists:取出外表的每一条记录，然后判断exists的条件
in:先将子查询条件的记录全部查出来，然后在对每一个条件进行判断

如果两个表中一个表大，另一个是表小，那么IN适合于外表大而子查询表小的情况；EXISTS适合于外表小而子查询表大的情况。

## 如何用好关联子查询

做测试来验证对子查询的执行计划和响应时间的假设。

## UNION的限制

有时MySQL无法将限制条件从外层“下推”到内层，这使得原本能够限制部分返回的结果的条件无法应用到内层查询优化上

## 索引合并优化

当WHERE字句中包含多个复杂条件的时候，MySQL能够访问当个表的多个索引以合并和交叉过滤的方式来定位需要查找的行

## 等值传递

## 并行执行

MySQL8 之前不支持并行执行

## 哈希关联

## 松散索引扫描

## 最大值和最小值优化

select MIN(actor_id) from actor where first_name = 'PENELOPE';

可以改写成：

select actor_id from actor use index(primary) where first_name = 'PENELOPE' limit 1;

## 在同一个表上查询和更新

MySQL不允许对同一张表同时进行查询和更新

## 查询优化器的提示

  * HIGH_PRIORITY和LOW_PRIORITY

    HIGH_PRIORITY用于SELECT语句的时候，MySQL会将此SELECT语句重新调度到所有正在等待表锁以便修改数据的语句之前。

    LOW_PRIORITY则正好相反：它会让该语句一致处于等待状态，只要队列中还有需要访问同一个表的语句。

  * DELAYED

    这个提示对INSERT和REPLACE有效。MySQL会将使用该提示的语句立即返回给客户端，并将插入的行数据放入到缓冲区，然后在表的空闲时批量将数据写入。

  * STARIGHT_JOIN 

    这个提示可以防止在SELECT语句的SELECT关键字之后，也可以放置在任何两个关联表的名字之间。第一个用法是让查询中所有的表按照在语句中出现的顺序进行关联。第二个则是固定其前后两个表的关联顺序
  
  * SQL_SMALL_RESULT和SQL_BIG_RESULT

    只对SELECT有效，告诉优化器对ORDER BY或者DISTINCT查询如何使用临时表及排序。SQL_SMALL_RESULT告诉优化器结果集会很小，可以将结果集存放在内存中的索引临时表，以避免排序操作。如果是SQL_BIG_RESULT，则告诉优化器结果集可能会非常大，建议使用磁盘临时表做排序操作

  * SQL_BUFFER_RESULT

    告诉优化器将查询结果放入到一个临时表，然后尽可能快的释放表锁

  * SQL_CACHE和SQL_NO_CACHE

    告诉MySQL这个结果集是否应该缓存在查询缓存中

  * FOR UPDATE 和LOCK IN SHARE MODE

    使用该提示会对符合查询条件的数据行加锁

  * USING INDEX、IGNORE INDEX和FORCE INDEX

    告诉优化器使用或者不适用那些索引来查询记录。FORCE INDEX会告诉优化器全表扫描的成本会远远高于索引扫描，哪怕实际上该索引用处不大

## 优化特定类型的查询

  * 优化COUNT()查询

    统计行可以用COUNT(*)，通配符\*并不会扩展成所有的列

    * 简单的优化

      快速查找所有ID大于5的城市

      select (select count(\*) from world.City) - count(*) from world.city where ID <=5;

    * 使用近似值

      某些业务场景并不要求完全精确的COUNT值，可以用近似值来替代。EXPLAIN出来的优化器估算的行数就是个不错的近似值

    * 更复杂的优化

      使用覆盖索引扫描、增加汇总表、增加类似memcached这样的外部缓存系统

  * 优化关联查询

    * 确保ON或者USING子句中的列上有索引。在创建索引的时候就要考虑到关联的顺序。当表A和表B用列c关联的时候，如果优化器的关联顺序是B、A,那么就不需要在表B的对应列上建上索引
    * 确保任何的GROUP BY 和ORDER BY中的表达式只涉及到一个表中的列，这样MySQL才有可能使用索引来优化这个过程。
    * 当升级MySQL的时候需要注意：关联语法、运算符优先级等其他可能会发生变化的地方。

  * 优化子查询

    尽可能使用关联查询替代

  * 优化GROUP BY和DISTINCT

    在MySQL中，当无法使用索引的时候，GROUP BY使用两种策略来完成：使用临时表或者文件排序来做分组。可以通过使用提示SQL_BIG_RESULT和SQL_SMALL_RESULT来让优化器按照你希望的方式运行。

    如果需要对关联查询做分组，并且是按照查找表中的某个列进行分组，那么通常采用查找表的标识列分组效率回避其他列更高。

    select actor.first_name, actor.last_name. COUNT(*) from sakila.file_actor inner join sakila.actor using(acotr_id) group by actor.first_name, actor.last_name;

    改写成：

    select actor.first_name, actor.last_name. COUNT(*) from sakila.file_actor inner join sakila.actor using(acotr_id) group by file_actor.actor_id;

    select后面出现的非分组列一定是直接依赖分组列，并且在每个组内的值是唯一的，或者是业务上根本不在乎这个值具体是什么。

  * 优化GROUP BY WITH ROLLUP

    对返回的分组结果再做一次超级聚合。尽可能将WITH ROLLUP功能转移到应用程序中处理。

  * 优化LIMIT分页

    尽可能使用覆盖索引，使用子查询延迟关联

  * 优化SQL_CALC_FOUND_ROWS

    加上这个提示以后，不管是否需要，MySQL都会扫描所有满足条件的行，然后在抛掉不需要的行，而不是在满足LIMIT的行数后就终止扫描

  * 优化UNION查询

    MySQL总是通过创建并填充临时表的方式来执行UNION查询。除非确实需要服务器消除重复的行，否则就一定要使用UNION ALL。如果没有ALL关键字，MySQL会给临时表加上DISTINCT选项。

  * 静态查询分析

  * 使用用户自定义变量

    不能使用用户自定义变量：

    * 使用自定义变量查询，无法使用查询缓存
    * 不能在使用常量或者标识符的地方使用自定义变量
    * 用户自定义变量的生命周期是在一个连接中有效，所以不能用他们来做连接间的通信
    * 如果使用连接词或者持久化连接，自定义变量可能看起来毫无关系的代码发生交互。
    * 不能显式的声明自定义变量的类型
    * MySQL优化器在某些场景下可能会将这些变量优化掉
    * 赋值的顺序和赋值的时间点并不总是固定
    * 赋值符号的优先级非常低
    * 使用未定义变量不会产生任何语法错误


