---
layout: post
title:  "查询性能优化"
date:   2020-06-27 15:00:00 +0800
categories: 高性能mysql
tags: mysql
description: 笔记
---

# 为什么查询会慢

# 慢查询基础： 优化数据访问

* 确认应用程序是否在检索大量超过需要的数据，这通常意味着访问太多的行，但有时候也可能是访问了太多的列。
* 确认MySQL服务器层是否在分析大量超过需要的数据行

## 是否向数据库请求了不需要的数据

  * 查询不需要的记录
  * 多表关联式返回全部列
  * 总是取出全部列
  * 重复查询相同的数据

## MySQL是否在扫描额外的记录

  * 响应时间

    包括服务时间和排队时间。服务时间是指数据库处理这个查询真正花了多长时间，排队时间是指服务器因为等待某些资源而没有真正执行查询的时间。
  * 扫描的行数和返回的行数。
  * 扫描的行数和访问的类型

    在EXPLAIN语句中的type列反映了访问类型。

    一般MySQL能够使用如下三种方式应用WHERE条件，从好到坏依次为：

    * 在索引中使用where条件来过滤不匹配的记录
    * 使用索引覆盖扫描（在Extra列中出现了Using index）来返回记录，直接从索引中过滤不需要的记录并返回名字的结果
    * 从数据表中返回数据，然后过滤不满足条件的记录（在Extra列中出现Using Where）

    如果发现查询需要扫描大量的数据但只返回少数的行，那么可以尝试下面的技巧去优化：

    * 使用索引覆盖扫描
    * 改变库表结构
    * 重写查询

# 重构查询的方式

  * 一个复杂查询还是多个简单查询

    考虑是否需要将一个复杂的查询分成多个简单的查询
  * 切分查询

    将大查询切分成小查询，每个查询功能完全一样，只完成一小部分，每次只返回一小部分查询结果。
  * 分解关联查询

    对每一个表进行一次单表查询，然后将结果在应用程序中进行关联。

    用分解关联查询的方式重构查询有如下的优势：

    * 让缓存的效率更高
    * 将查询分解后，执行单个查询可以减少锁的竞争
    * 在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展
    * 查询本身效率也可能会有所提升
    * 可以减少冗余记录的查询
    * 这样做相当于在应用中实现了哈希关联，而不是使用MySQL的嵌套循环关联

# 查询执行的基础

## MySQL客户端/服务器通信协议

  MySQL客户端和服务器之间的通信协议是“半双工”的。多数连接MySQL的库函数都可以获得全部结果集并缓存到内存里，还可以逐行获取需要的数据。如果需要返回一个很大的结果集，可以不使用缓存来记录结果而是直接处理。

## 查询状态

  * Sleep 线程正在等待客户端发送新的请求
  * Query 线程正在执行查询或者正在将结果发送给客户端
  * Locked 在MySQL服务器层，该线程正在等待表锁
  * Analyzing and statistics 线程正在收集存储引擎统计信息，并生成查询的执行计划
  * Coping to tmp table [on disk] 线程正在执行查询，并且将其结果都复制到一个临时表中。
  * Sorting result 线程正在对结果集进行排序
  * Sending data 县城可能在多个状态之间传送数据，或者在生成结果集，或者在向客户端返回数据

## 查询缓存

  在解析一个查询语句之前，如果查询缓存是打开的，那么MySQL会优先检查这个查询是否名字查询缓存中的数据。这个检查是通过一个对大小写铭感的哈希查找实现的。

## 查询优化处理

  * 语法解析器和预处理

    MySQL通过关键字将SQL语句进行解析，并生成一颗对应的“解析树”。MySQL解析器将使用MySQL语法规则验证和解析查询。

  * 查询优化器

    一条查询可以有很多种执行方式，最后都返回相同的结果。优化器的作用就是找到这其中最好的执行计划。

    有很多种原因会导致MySQL优化器选择错误的执行计划：

    * 统计信息不准确
    * 执行计划中的成本估算不等同于实际执行的成本
    * MySQL的最优可能和你想的最优不一样
    * MySQL从不考虑其他并发执行的查询
    * MySQL也并不是任何时候都是基于成本的优化，有时也会基于一些固定规则
    * MySQL不会考虑不受控制的操作成本，如执行存储过程或者用户自定义函数



