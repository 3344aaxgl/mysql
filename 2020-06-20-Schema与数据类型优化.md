---
layout: post
title:  "Schema与数据类型优化"
date:   2020-06-20 08:00:00 +0800
categories: 高性能mysql
tags: mysql
description: 笔记
---

# 选择优化的数据类型

* 更小的通常更好

    更小的数据类型通常更快，因为他们占用更少的磁盘、内存和CPU缓存，并且处理时需要的CPU周期也更少

* 简单就好
  
    简单数据类型的操作通常需要更少的CPU周期。整型比字符操作代价更低，应该用mysql内建类型而不是字符串来存储日期和时间，应该用整型存储IP地址

* 尽量避免NULL

    可以为NULL的列是的索引、索引统计和值都比较复杂，可为NULL的列会使用更多的存储空间

## 整数类型

如果存储整数，可以使用：TINYINT，SMALLINIT，MEDIUMINT，INT，BIGINT。分别使用8，16，24，32，64位的存储空间。整数类有可选的UNSIGNED属性，可以表述不允许负值，可以是整数上限提高一倍。

MySQL可以为整数类型指定宽度，例如INT(11)，但 **存储空间不变**。

## 实数类型

实数是带有小数部分的数字。也可以使用DECIMAL存储比BIGINT还大的整数。MySQL既支持精确类型，也支持不精确类型。CPU不支持DECIMAL的直接计算，所以MySQL服务器自身实现了DECIMAL的高精度计算，浮点的运算速度更快。

* DECIMAL
  
  CPU不支持直接计算，所以MySQL服务器自身实现了DECIMAL的高精度计算。可以指定小数点前后所允许的最大位数。这回影响列的空间消耗。每4字节存9个数字，小数点占一个字节，最多允许65个数字

* 浮点类型

  CPU支持直接计算，MySQL使用DOUBLE作为内部浮点计算的类型。FLOAT使用4字节存储，DOUBLE使用8字节，可以指定精度。

## 字符串类型

* VARCHAR

  VAECHAR类型用于存储可变长字符串，比定长的类型更节省空间，因为仅使用必要的空间。需要使用1或2个额外的字节记录字符串的长度：如果列的最大长度小于或等于255，则使用1个字节，否则使用2个字节。更新VARCHAR时可能使得行变得比原来更长，这就导致需要做额外的工作。InnoDB需要分裂页来使行可以放进页内。

  下面这些情况使用VARCHAR是合适的：
  * 字符串列的最大长度比平均长度大很多
  * 列的更新很少
  * 使用了UTF-8这样复杂的字符集，每个字符使用不同的字节数进行存储

  在5.0及或者更高的版本，MySQL会在存储和检索时保留末尾空格

* CHAR

  CHAR类型是定长的：MySQL总是根据定义的字符串长度分配足够的空间。当存储CHAR值时，MySQL会删除所有末尾空格。


**使用合适大小的空间时明智的，更长的列会消耗更多的内存，因为MySQL通常会分配固定大小的内存块来保存内部值，尤其是使用内存临时表进行排序或操作时会特别糟糕。在利用磁盘临时表进行排序时也同样糟糕。**

 * BLOB和TEXT类型

  BLOB和TEXT都是为存储很大的数据而设计的字符串数据类型，分别采用二进制和字符方式存储。字符类型是：TINYTEXT，SMALLTEXT，TEXT，MEDIUMTEXT，LONGTEXT；对应的二进制类型是TINYBLOB，SMALLBLOB，BLOB，MEDIUMBLOB，LONGBLOB。BLOB和SMALLBLOB是同义词，TEXT和SMALLTEXT是同义词。

  当BLOB和TEXT值太大时，InnoDB会使用专门的“外部”存储区域来进行存储，此时每个值在行内需要1~4个字节存储一个指针，然后在外部存储区存储实际的值。

  BLOB类型存储的是二进制数据，没有排序规则或字符集，而TEXT类型有字符集和排序规则。MySQL只对每个列的前max_sort_length字节而不是整个字符串做排序。

  **如果EXPLAIN执行计划的Ectra列包含“Using temporary”，则说明这个查询使用了隐式临时表**

  * 使用枚举替代字符串类型

    MySQL在存储枚举类型时会根据列表值的数量压缩到一个或者两个字节中，会将每个值在列表中的位置保存为整数，并且在表的.frm文件中保存“数字-字符串”映射关系的“查找表”。

    * 缺点。字符串列表是固定，添加或者删除字符串必须使用ALTER TABLE。把CHAR/VARCHAR列与枚举列进行关联可能会比直接关联CHAR/VARCHAR列更慢
    * ENUM与ENUM关联会比较快，把列ENUM可以让表的大小缩小。

## 日期和时间类型

  * DATETIME

    这个类型能保存大范围的值，从1001到9999年，精度为秒把日期和时间封装到格式为YYYYMMDDHHMMSS的整数中，与时区无关。使用8字节的存储空间。
  * TIMESTAMP

    TIMESTAMP类型保存了从1970年1月1日午夜以来的秒数，它和UNIX时间戳相同，TIMESTAMP只使用4字节存储空间，只能表示1970到2038年。TIMESTAMP显示的值也依赖于时区。如果插入时没有指定第一个TIMESTAMP列的值，MySQL则设置这个列的值为当前时间。，在插入一行记录时，MySQL也会更新第一个TIMESTAMP列的值。在5.6.4及之后的版本，时间戳类型数据最高精确微妙。

## 位数据类型

  * BIT
  
    InnoDB为每个BIT列使用一个足够存储的最小整数类型才存放。并不能节省空间。MySQL把BIT当作字符串类型，而不是数字类型。

  * SET

    如果需要保存很多true/false值，可以考虑合并这些列到一个SET数据类型，它在MySQL内部是以一系列打包的位集合来表示的。

## 选择标识符

  * 整数通常是标识列最好的选择，因为他们很快并且可以使用AUTO_INCREMENT
  * ENUM和SET类型通常是一个糟糕的选择，尽管对某些只包含固定状态或者类型的静态“定义表”来说可能是没有问题的。
  * 如果可能，应该避免使用字符串类型作为标识符，因为他们很消耗空间，并且通常比数字类型慢。


# MySQL schema设计中的陷阱

  * 太多的列
  * 太多的关联
  * 全能的枚举
  * 变相的枚举。枚举列允许在列中存储一组定义值中的单个值，集合列则允许在列中存储一组定义值中的一个或多个值。
  
# 范式和反范式

## 范式的优点和缺点

  * 范式化的更新操作通常比反范式化要快
  * 当数据较好的范式化时，就只有很少或者没有重复数据，所以只需要修改更少的数据
  * 范式化的表通常更小，可以更好的放在内存里，所以执行操作会更快
  * 很少有多余的数据意味着检索列表时更少需要DISTINCT或者GROUP BY语句。

  范式化设计的schema的缺点是通常需要关联。代价昂贵，也可能使一些索引策略失效。

## 反范式的优点和缺点

  反范式话的schema因为所有数据都在一张表中，可以很好的避免关联。

## 混用范式化和反范式化

# 缓存表和汇总表

  * “缓存表”表示存储那些可以比较简单的从schema其他表获取（但是每次获取的速度比较慢）数据的表。
  * “汇总表”保存的是使用GROUP BY语句聚合数据的表。
  
## 物理化视图

  物化视图是预先计算并且存储在磁盘上的表，可以通过各种各样的策略刷新和更新。

## 计数器表

  将计数器保存在多行中，每次随机选择一行更新。查询结果时，用聚合查询统计结果，这样在对计数器更新时，不用锁整张表

# 加快ALTER TABLE操作的速度

## 只修改.frm文件

  * 移除(不是增加)一个列的AUTO_INCREMENT属性
  * 增加、移除，或更改ENUM和SET常量。如果移除的是已经有行数据用到其值的常量，查询将会返回一个空字符串

  基本操作：

  * 创建一张有相同结构的空表，并进行所需要的修改
  * 执行FLUSH TAVLES WITH READ LOCK。这将会关闭所有正在使用的表，并禁止任何表被打开。
  * 交换.frm文件
  * 执行UNLOCK TABLES 来释放第2步的读锁

## 快速创建MyISAM索引
  为了高效地载入数据到MyISAM表中，有一个常用的技巧是先禁用索引、载入数据，然后重新启用索引。此方法对唯一索引无效。

  InnoDB类似技巧：

  * 用需要的表结构创建一张表，但是不包括索引
  * 载入数据到表中以构建.MYD文件
  * 按照需要的结构创建另外一张空表，这次要包含索引。这回创建需要的.frm和.MYI文件
  * 获取读锁并刷新新表
  * 重命名第二章表的.frm和.MYI文件，并让MySQL认为是第一张表的文件
  * 释放读锁
  * 使用REPAIR TABLE来重建表的索引。